function parseFinancialOrPercentString(str) {
  if (typeof str !== 'string') return NaN;

  // Define multipliers for suffixes
  const suffixes = {
    K: 1e3,   // Thousand
    M: 1e6,   // Million
    B: 1e9,   // Billion
    T: 1e12,  // Trillion
    '%': 0.01 // Percentage → divide by 100
  };

  // Remove $, commas, and whitespace
  let cleaned = str.replace(/[$,\s]/g, '').trim();

  // Match optional minus, digits (with decimal), optional suffix (%, K, M, B, T)
  const match = cleaned.match(/^(-?)(\d+(?:\.\d+)?)([%KMBT]?)$/i);

  if (!match) return NaN;

  const [, sign, numberStr, suffix] = match;
  let num = parseFloat(numberStr);

  // Apply sign
  if (sign === '-') num = -num;

  // Apply multiplier if suffix exists
  if (suffix) {
    const key = suffix.toUpperCase();
    const multiplier = suffixes[key] !== undefined ? suffixes[key] : NaN;
    if (isNaN(multiplier)) return NaN; // Unsupported suffix
    num *= multiplier;
  }

  return num;
}function jsonToCsv(data) {
  if (!data || !data.length) return "";

  const headers = Object.keys(data[0]);
  let csv = headers.join(",") + "\n";  // start with header row

  for (let i = 0; i < data.length; i++) {
    let row = "";
    for (let j = 0; j < headers.length; j++) {
      const val = data[i][headers[j]] ?? "";
      const safe = String(val).replace(/"/g, '""');
      row += `"${safe}"` + (j < headers.length - 1 ? "," : "");
    }
    csv += row + (i < data.length - 1 ? "\n" : "");
  }

  return csv;
}


    keys_to_keep = ["id", "name", "age", "city", "status"]
    filtered = {k: data[k] for k in keys_to_keep if k in data}
    return filtered
import urllib
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base, sessionmaker
from azure.identity.aio import DefaultAzureCredential
from azure.keyvault.secrets.aio import SecretClient
from azure.identity import ClientSecretCredential

# SQLAlchemy Base
Base = declarative_base()

# These come from your Azure setup
TENANT_ID = "<your-tenant-id>"
CLIENT_ID = "<your-client-id>"
SERVER = "<your-sql-server-name>.database.windows.net"
DATABASE = "<your-database-name>"
KEY_VAULT_URL = "https://<your-keyvault-name>.vault.azure.net"
SECRET_NAME = "MyClientSecret"

# Engine placeholder
sqlserver_engine = None
SessionLocal = None


async def init_db_engine():
    global sqlserver_engine, SessionLocal

    # 1. Fetch client secret from Azure Key Vault
    credential = DefaultAzureCredential()
    secret_client = SecretClient(vault_url=KEY_VAULT_URL, credential=credential)

    secret_bundle = await secret_client.get_secret(SECRET_NAME)
    CLIENT_SECRET = secret_bundle.value

    # Close Key Vault client
    await credential.close()
    await secret_client.close()

    # 2. Get token for SQL DB using client creds
    cred = ClientSecretCredential(
        tenant_id=TENANT_ID,
        client_id=CLIENT_ID,
        client_secret=CLIENT_SECRET,
    )
    token = cred.get_token("https://database.windows.net/.default")

    # 3. Build ODBC connection string
    odbc_str = (
        "Driver={ODBC Driver 17 for SQL Server};"
        f"Server={SERVER};"
        f"Database={DATABASE};"
        "Encrypt=yes;"
        "TrustServerCertificate=no;"
        "Connection Timeout=30;"
    )

    params = urllib.parse.quote_plus(odbc_str)

    # 4. Create SQLAlchemy engine
    sqlserver_engine = create_engine(
        f"mssql+pyodbc:///?odbc_connect={params}",
        connect_args={"attrs_before": {1256: token.token}},
    )

    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=sqlserver_engine)
    print("✅ SQL Server Engine initialized!")


# Example: FastAPI lifespan hook
from fastapi import FastAPI
from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    await init_db_engine()
    yield
    # You can add engine.dispose() here if needed

app = FastAPI(lifespan=lifespan)
