// features/interaction/interactionSlice.ts
import {
  createSlice,
  createAsyncThunk,
  createEntityAdapter,
  PayloadAction,
} from "@reduxjs/toolkit";
import { RootState } from "../../app/store";
import {
  fetchInteractionsAPI,
  sendMessageAPI,
} from "../../services/api";

// ðŸ”¹ Interaction type
export interface Interaction {
  interactionId: string;
  sessionId: string;
  userMessage: string;
  botMessage: string;
}

// ðŸ”¹ Entity adapter
const interactionsAdapter = createEntityAdapter<Interaction>({
  selectId: (i) => i.interactionId,
  sortComparer: (a, b) => a.interactionId.localeCompare(b.interactionId),
});

// ðŸ”¹ Async thunks
export const fetchInteractions = createAsyncThunk(
  "interactions/fetch",
  async (sessionId: string) => {
    return await fetchInteractionsAPI(sessionId);
  }
);

export const sendMessage = createAsyncThunk(
  "interactions/sendMessage",
  async (
    { sessionId, userMessage }: { sessionId: string; userMessage: string },
    { rejectWithValue }
  ) => {
    try {
      const newInteraction = await sendMessageAPI(sessionId, userMessage);
      return newInteraction;
    } catch (err) {
      return rejectWithValue(err);
    }
  }
);

// ðŸ”¹ Slice state
interface InteractionState {
  activeSessionId: string | null;
  interactionsBySession: Record<string, string[]>; // map sessionId -> [interactionIds]
  loading: boolean;
}

const initialState = interactionsAdapter.getInitialState<InteractionState>({
  activeSessionId: null,
  interactionsBySession: {},
  loading: false,
});

const interactionSlice = createSlice({
  name: "interactions",
  initialState,
  reducers: {
    setActiveSessionId(state, action: PayloadAction<string | null>) {
      state.activeSessionId = action.payload;
    },
    clearSessionInteractions(state, action: PayloadAction<string>) {
      const sessionId = action.payload;
      const ids = state.interactionsBySession[sessionId] || [];
      interactionsAdapter.removeMany(state, ids);
      delete state.interactionsBySession[sessionId];
    },
  },
  extraReducers: (builder) => {
    builder
      // Fetch interactions
      .addCase(fetchInteractions.pending, (state) => {
        state.loading = true;
      })
      .addCase(fetchInteractions.fulfilled, (state, action) => {
        const sessionId = action.meta.arg;
        interactionsAdapter.upsertMany(state, action.payload);

        // map sessionId -> interactionIds
        state.interactionsBySession[sessionId] = action.payload.map(
          (i: Interaction) => i.interactionId
        );
        state.loading = false;
      })
      .addCase(fetchInteractions.rejected, (state) => {
        state.loading = false;
      })
      // Send message
      .addCase(sendMessage.fulfilled, (state, action) => {
        const interaction = action.payload;
        interactionsAdapter.addOne(state, interaction);

        if (!state.interactionsBySession[interaction.sessionId]) {
          state.interactionsBySession[interaction.sessionId] = [];
        }
        state.interactionsBySession[interaction.sessionId].push(
          interaction.interactionId
        );
      });
  },
});

export const { setActiveSessionId, clearSessionInteractions } =
  interactionSlice.actions;

// ðŸ”¹ Selectors
export const {
  selectAll: selectAllInteractions,
  selectById: selectInteractionById,
} = interactionsAdapter.getSelectors((state: RootState) => state.interactions);

export const selectActiveSessionId = (state: RootState) =>
  state.interactions.activeSessionId;

export const selectInteractionsForActiveSession = (state: RootState) => {
  const sessionId = state.interactions.activeSessionId;
  if (!sessionId) return [];
  const ids = state.interactions.interactionsBySession[sessionId] || [];
  return ids.map((id) => selectInteractionById(state, id));
};

export default interactionSlice.reducer;
import {
  sendMessage,
  selectInteractionsForActiveSession,
} from "../features/interaction/interactionSlice";

function ChatWindow() {
  const dispatch = useAppDispatch();
  const interactions = useAppSelector(selectInteractionsForActiveSession);

